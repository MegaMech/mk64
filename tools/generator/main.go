package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os/exec"
    "gopkg.in/yaml.v3"
)

type Asset struct {
    Type    string  `yaml:"type"`
    Offset  int     `yaml:"offset"`
    Length  int     `yaml:"length,omitempty"`
    Comment string  `yaml:"comment,omitempty"`
}


// The yaml structure as Go
type FileList struct {

    Name string `yaml:"name"`
    Dir string  `yaml:"dir"`
    Type string `yaml:"type"`
    Assets []Asset
}



func main() {
	var yamlPath string
	var baseromPath string

	flag.StringVar(&yamlPath, "yaml", "", "Path to the YAML file")
    flag.StringVar(&baseromPath, "baserom", "", "Path to the baserom")
	flag.Parse()

    verify_main_args(yamlPath, baseromPath);


	yamlData, err := ioutil.ReadFile(yamlPath)
	if err != nil {
		log.Fatal("Failed to read YAML file:", err)
	}

    var fileList []FileList
    err = yaml.Unmarshal([]byte(yamlData), &fileList)
	if err != nil {
		log.Fatal("Failed to parse YAML: %v", err)
	}
    
    //rom, err := ioutil.ReadFile(baseromPath)
    //if err != nil {
    //    log.Fatal("Failed to read baserom: ", err)
    //}

    // Iterate over the list of entries for each file
	for _, file := range fileList {
    	textBuffer := ""
        fmt.Println("Generating Course Data for: ", file.Name)
        //print("Generating Course Data for: ", file.Name)
        textBuffer += "/* @file course generated by static extractor */\n\n"
	
        for _, asset := range file.Assets {
			switch asset.Type {
			case "vtx":
                generate_model(&textBuffer, asset.Offset, asset.Length);
			    break
            case "gfx":
                generate_gfx(&textBuffer, asset.Offset);
                break
			case "texture":
				// Call relative function for textures
				// ...
                break
            case "path":
                break
			default:
				log.Fatal("Unknown data type: ", asset.Type)
			    break
            }
		}

		// Write the file buffer to disk
        textBuffer += "EOF"
		err := ioutil.WriteFile(file.Dir, []byte(textBuffer), 0644)
		if err != nil {
			log.Println("Error writing to output file: ", err)
		}
	}
}

func verify_main_args(yamlPath string, baseromPath string) {
	if yamlPath == "" {
		log.Fatal("Missing YAML file path")
	}

    if baseromPath == "" {
        log.Fatal("Missing baserom file path")
    }
}

func print(text *string, value *string) {
  fmt.Println(text, value)
}

func execute_shell_program(path string, args []string) ([]byte, error) {
	cmd := exec.Command(path, args...)
	output, err := cmd.Output()
	if err != nil {
		return nil, err
	}
	return output, nil
}

