package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"strings"
    "gopkg.in/yaml.v3"
)

type Asset struct {
    Type    string  `yaml:"type"`
    Offset  int     `yaml:"offset"`
    Length  int     `yaml:"length,omitempty"`
    Comment string  `yaml:"comment,omitempty"`
}


// The yaml structure as Go
type FileList struct {

    Name string `yaml:"name"`
    Dir string  `yaml:"dir"`
    Type string `yaml:"type"`
    Assets []Asset
}

var rom *os.File

func main() {
	var yamlPath string
	var baseromPath string

	flag.StringVar(&yamlPath, "yaml", "", "Path to the YAML file")
    flag.StringVar(&baseromPath, "baserom", "", "Path to the baserom")
	flag.Parse()

    verify_main_args(yamlPath, baseromPath);

	fileList := open_yaml(yamlPath)
	open_baserom(baseromPath)

	var textBuffer strings.Builder
    // Iterate over the list of entries for each file
	for _, file := range fileList {
        fmt.Println("Generating Course Data for: ", file.Name)
		textBuffer.Reset();
        //print("Generating Course Data for: ", file.Name)
        textBuffer.WriteString("/* @file course generated by static extractor */\n\n")
	
        for _, asset := range file.Assets {
			switch asset.Type {
			case "vtx":
                generate_model(&textBuffer, asset.Offset, asset.Length);
			    break
            case "gfx":
                generate_gfx(&textBuffer, asset.Offset);
                break
			case "texture":
				// Call relative function for textures
				// ...
                break
            case "path":
                break
			default:
				log.Fatal("Unknown data type: ", asset.Type)
			    break
            }
		}

		// Write the file buffer to disk
        textBuffer.WriteString("\n\neof\n")
		err := ioutil.WriteFile("out/" + file.Dir, []byte(textBuffer.String()), 0644)
		if err != nil {
			log.Println("Error writing to output file: ", err)
		}
		// See you next time
		defer rom.Close()
	}
}

func verify_main_args(yamlPath string, baseromPath string) {
	if yamlPath == "" {
		log.Fatal("Missing YAML file path")
	}

    if baseromPath == "" {
        log.Fatal("Missing baserom file path")
    }
}

func open_yaml(yamlPath string) []FileList {

	yamlData, err := ioutil.ReadFile(yamlPath)

	if err != nil {
		log.Fatal("Failed to read YAML file:", err)
	}

    var fileList []FileList
    err = yaml.Unmarshal([]byte(yamlData), &fileList)
	if err != nil {
		log.Fatal("Failed to parse YAML: %v", err)
	}
	return fileList
}

func open_baserom(baseromPath string) {
    // Open the baserom file for reading
	var err error
	rom, err = os.Open(baseromPath)
	if err != nil {
		log.Fatal("Failed to open file:", err)
	}
	// Don't forget to close the file at the end of the program.
}

func print(text *string, value *string) {
  fmt.Println(text, value)
}

func execute_shell_program(path string, args []string) ([]byte, error) {
	cmd := exec.Command(path, args...)
	output, err := cmd.Output()
	if err != nil {
		return nil, err
	}
	return output, nil
}

